# Development Conventions

## 1. Feature Module Structure

All domain logic lives in `packages/shared/src/features/`. Each feature is a self-contained vertical slice with a standard directory structure:

```
packages/shared/src/features/{domain}/
  index.ts               # Barrel export
  types.ts               # Domain types and interfaces
  convex/                # Backend functions (Convex queries/mutations)
    convex.config.ts     # Component registration (defineComponent)
    schema.ts            # Table definitions for the component
    queries.ts           # Read operations (component-level)
    mutations.ts         # Write operations (component-level)
    contract.ts          # API contract definition
    {domain}.ts          # Domain facade functions (app-level)
    _generated/          # Auto-generated by Convex
  hooks/                 # React hooks
    index.ts             # Barrel export
    use-{domain}.ts      # Primary hook file
  adapters/              # Data transformation (optional)
  presenters/            # Presentation logic (optional)
  utils/                 # Domain utilities (optional)
```

The `_shared` feature is special -- it contains cross-cutting infrastructure used by all features:

```
features/_shared/
  lib/                   # Convex infrastructure
    auth.ts              # Auth helpers
    batchGet.ts          # Batch data fetching
    componentContract.ts # defineContract() for component API shapes
    componentMiddleware.ts # Middleware: auth, tenant, rate limit, RLS, audit
    crud.ts              # CRUD helpers
    eventBus.ts          # Outbox pattern for component communication
    functions.ts         # Tenant-aware custom function builders
    rateLimits.ts        # Per-tenant/per-user rate limiting
    rls.ts               # Row-level security
    triggers.ts          # Database triggers with event bus
    validators.ts        # Shared validators
  hooks/                 # Shared hook utilities
    convex-utils.ts      # Cached query hooks (useQuery, useMutation, etc.)
    convex-api.ts        # Generated API + typed IDs
    transforms/common.ts # Pagination, response wrappers
  convex/                # App-level cross-cutting functions
    types.ts             # Status enums, doc types
    storage.ts           # File storage API
    modules.ts           # Feature module catalog
    ops.ts               # System health/metrics
  use-help.ts            # FAQ/guides hook
  use-accessibility-monitoring.ts  # A11y metrics hook
```

---

## 2. Import Rules

The architecture enforces strict import boundaries. Violations break the separation of concerns and make components non-swappable.

### Allowed Imports

| From | Can Import |
|------|-----------|
| **Apps** | `@xalabaas/sdk`, `@xalabaas/shared`, `@xalabaas/app-shell`, `@xala/ds` or `@xala-technologies/platform-ui`, `@xalabaas/i18n` |
| **SDK hooks** (`packages/sdk/src/hooks/`) | `features/{domain}/hooks/` (re-export only) |
| **Feature hooks** (`features/{domain}/hooks/`) | `features/_shared/hooks/convex-utils`, `features/_shared/hooks/convex-api`, `features/_shared/hooks/transforms`, other feature hooks via relative paths (e.g., `../../tenant-config/hooks/use-tenant-id`) |
| **Facade functions** (`features/{domain}/convex/{domain}.ts`) | `convex/_generated/server` (app-level), `convex/_generated/api` (for components), core table types |
| **Component functions** (`features/{domain}/convex/queries.ts`, `mutations.ts`) | `./_generated/server` (component-level), `convex/values` |
| **Re-export files** (`convex/domain/`, `convex/components/`) | The feature module they wrap (single-line re-export) |

### Forbidden Imports

| From | Must NOT Import |
|------|----------------|
| Apps | `convex/`, `features/`, `packages/sdk/src/` directly |
| Component functions | Other components' tables or functions directly |
| SDK hooks | `convex/_generated/` directly (use `convex-api.ts`) |
| Feature A hooks | Feature B hooks (except `_shared` and `tenant-config`) |

### Import Path Conventions

- **App-level functions** in features use the 6-level relative path: `../../../../../../convex/_generated/server`
- **Component functions** use the local generated path: `./_generated/server`
- **Cross-feature hook deps** use relative paths: `../../tenant-config/hooks/use-tenant-id`
- **Hooks always import** `useQuery`/`useMutation` from `features/_shared/hooks/convex-utils` (cached versions), never from `convex/react` directly.

---

## 3. Convex Function Patterns

There are three levels of Convex functions, each with distinct responsibilities.

### Component Functions

Located in `features/{domain}/convex/queries.ts` and `mutations.ts`. These operate within the component's isolated database.

```typescript
// features/reviews/convex/queries.ts
import { query } from "./_generated/server";   // Component's own server
import { v } from "convex/values";

export const list = query({
  args: {
    tenantId: v.string(),       // v.string() for ALL external references
    resourceId: v.optional(v.string()),
    status: v.optional(v.string()),
    limit: v.optional(v.number()),
  },
  returns: v.array(v.any()),
  handler: async (ctx, args) => {
    let q = ctx.db.query("reviews")
      .withIndex("by_tenant", q => q.eq("tenantId", args.tenantId));
    // ... filtering logic
    return q.collect();
  },
});
```

Key rules:
- Use `v.string()` for ALL external references (tenant IDs, user IDs, resource IDs, etc.)
- Never use `v.id("tableName")` for tables that live in other components or in core
- Can only access tables defined in this component's `schema.ts`
- Cannot call other components' functions directly

### Facade Functions

Located in `features/{domain}/convex/{domain}.ts`. These bridge the SDK and components.

```typescript
// features/reviews/convex/reviews.ts
import { query, mutation } from "../../../../../../convex/_generated/server";  // App's server
import { components } from "../../../../../../convex/_generated/api";
import { v } from "convex/values";

export const list = query({
  args: {
    tenantId: v.id("tenants"),  // Typed IDs from SDK
    resourceId: v.optional(v.id("resources")),
    status: v.optional(v.string()),
    limit: v.optional(v.number()),
  },
  handler: async (ctx, { tenantId, resourceId, ...rest }) => {
    // 1. Delegate to component (convert typed ID to string)
    const data = await ctx.runQuery(components.reviews.functions.list, {
      tenantId: tenantId as string,
      resourceId: resourceId as string | undefined,
      ...rest,
    });

    // 2. Enrich with core table data (user names, etc.)
    const enriched = await Promise.all(data.map(async (review) => {
      const user = await ctx.db.get(review.userId as any);
      return { ...review, user: user ? { id: user._id, name: user.name } : undefined };
    }));

    // 3. Return enriched data to SDK
    return enriched;
  },
});

export const create = mutation({
  args: {
    tenantId: v.id("tenants"),
    resourceId: v.id("resources"),
    userId: v.id("users"),
    rating: v.number(),
    title: v.optional(v.string()),
    text: v.optional(v.string()),
    metadata: v.optional(v.any()),
  },
  handler: async (ctx, args) => {
    // 1. Validate inputs
    // 2. Delegate to component
    const result = await ctx.runMutation(components.reviews.functions.create, {
      tenantId: args.tenantId as string,
      resourceId: args.resourceId as string,
      userId: args.userId as string,
      rating: args.rating,
      title: args.title,
      text: args.text,
    });

    // 3. Create audit entry
    await ctx.runMutation(components.audit.functions.create, {
      tenantId: args.tenantId as string,
      action: "review.created",
      userId: args.userId as string,
      resourceId: args.resourceId as string,
      details: { reviewId: result.id },
    });

    // 4. Emit event to bus
    await ctx.runMutation(internal.lib.eventBus.emit, {
      topic: "reviews.review.created",
      tenantId: args.tenantId as string,
      sourceComponent: "reviews",
      payload: { reviewId: result.id },
    });

    return result;
  },
});
```

Facade responsibilities:
1. Accept typed `v.id("tableName")` args from SDK
2. Convert to `v.string()` for component calls
3. Enrich results with core table data (user names, resource names, etc.)
4. Create audit entries via the audit component
5. Emit events to the event bus
6. Apply rate limiting via `withRateLimit()`

### App-Level Functions

Located in `features/_shared/convex/` or directly in feature modules. These operate on core tables.

```typescript
// features/_shared/convex/modules.ts
import { query } from "../../../../../../convex/_generated/server";
import { v } from "convex/values";

export const listEnabledModuleIds = query({
  args: { tenantId: v.id("tenants") },
  handler: async (ctx, args) => {
    const registrations = await ctx.db.query("componentRegistry")
      .withIndex("by_tenant", q => q.eq("tenantId", args.tenantId))
      .filter(q => q.eq(q.field("isEnabled"), true))
      .collect();
    return registrations.map(r => r.componentId);
  },
});
```

---

## 4. Adding a New Feature

Step-by-step checklist for creating a new feature module:

### Step 1: Create the Feature Module

Create the directory at `packages/shared/src/features/{name}/`:

```
features/{name}/
  index.ts
  types.ts
  convex/
    convex.config.ts
    schema.ts
    queries.ts
    mutations.ts
    contract.ts
    {name}.ts          # Facade
    _generated/        # Created by Convex
  hooks/
    index.ts
    use-{name}.ts
```

### Step 2: Define the Component

In `convex/convex.config.ts`:
```typescript
import { defineComponent } from "convex/server";
export default defineComponent("{name}");
```

In `convex/schema.ts`:
```typescript
import { defineSchema, defineTable } from "convex/server";
import { v } from "convex/values";

export default defineSchema({
  {tableName}: defineTable({
    tenantId: v.string(),    // Always string for external refs
    // ... domain fields
  }).index("by_tenant", ["tenantId"]),
});
```

### Step 3: Create Re-Export Wrappers

Create `convex/components/{name}/` with files pointing back to features:

```typescript
// convex/components/{name}/convex.config.ts -- REAL (not re-export)
import { defineComponent } from "convex/server";
export default defineComponent("{name}");

// convex/components/{name}/queries.ts -- RE-EXPORT
export * from '../../../packages/shared/src/features/{name}/convex/queries';

// convex/components/{name}/mutations.ts -- RE-EXPORT
export * from '../../../packages/shared/src/features/{name}/convex/mutations';

// convex/components/{name}/schema.ts -- RE-EXPORT
export { default } from '../../../packages/shared/src/features/{name}/convex/schema';
```

### Step 4: Register the Component

In `convex/convex.config.ts`:
```typescript
import {name} from "./components/{name}/convex.config";
app.use({name});
```

### Step 5: Create the Facade

In `features/{name}/convex/{name}.ts`, create facade functions that delegate to component functions and enrich results.

Create a re-export in `convex/domain/{name}.ts`:
```typescript
export * from '../../packages/shared/src/features/{name}/convex/{name}';
```

### Step 6: Create SDK Hooks

In `features/{name}/hooks/use-{name}.ts`, create hooks that call `api.domain.{name}.*`.

Create a re-export in `packages/sdk/src/hooks/use-{name}.ts`:
```typescript
export * from '../../../shared/src/features/{name}/hooks/use-{name}';
```

Export from `packages/sdk/src/hooks/index.ts`.

### Step 7: Generate and Seed

```bash
npx convex dev          # Generates _generated/ for the component
```

Add seed data in `convex/seedComponents.ts`.

### Step 8: Write Tests

- Convex function tests in `tests/convex/{name}/`
- SDK hook tests in `packages/sdk/src/__tests__/use-{name}.test.ts`

---

## 5. Error Handling

All errors follow RFC 7807 (Problem Details for HTTP APIs):

```typescript
interface ProblemDetails {
  type: string;        // URI identifying the error type
  title: string;       // Short human-readable summary
  status: number;      // HTTP status code
  detail: string;      // Human-readable explanation
  instance?: string;   // URI identifying the specific occurrence
}
```

Example error thrown from a Convex function:

```typescript
throw new Error(JSON.stringify({
  type: "urn:xalabaas:error:booking:conflict",
  title: "Booking Conflict",
  status: 409,
  detail: "The requested time slot is already booked",
  instance: `/bookings/${bookingId}`,
}));
```

In hooks, errors are captured in the `error` state and can be presented to the user via the design system's error components.

---

## 6. Internationalization (i18n)

### Default Locale

Norwegian Bokmal (`nb`) is the default locale. All UI strings must have an `nb` translation. English (`en`) and Arabic (`ar`, RTL) are supported as additional locales.

### Package

All translations live in `@xalabaas/i18n` (`packages/i18n/`):

```
packages/i18n/
  src/index.ts           # i18next setup, exports useT, I18nProvider, etc.
  locales/
    nb.json              # Norwegian translations (primary)
    en.json              # English translations
    ar.json              # Arabic translations (RTL)
```

### The `useT()` Hook

The primary translation hook. Returns a function `t(key, defaultValue?)`:

```typescript
import { useT } from '@xalabaas/i18n';

function MyComponent() {
  const t = useT();
  return <h1>{t('dashboard.title', 'Oversikt')}</h1>;
}
```

The second argument is a default value used as a fallback when the key is missing. This is also the value displayed during development if the translation is not yet added to the JSON files.

### Translation Key Convention

Keys are namespaced by domain: `{domain}.{section}.{key}`

```json
{
  "common": {
    "search": "Sok",
    "save": "Lagre",
    "cancel": "Avbryt"
  },
  "bookings": {
    "title": "Bestillinger",
    "status": {
      "pending": "Venter",
      "confirmed": "Bekreftet"
    }
  }
}
```

### RTL Support

Arabic (`ar`) is RTL. The `getDirection()` function returns `'rtl'` for Arabic. The `XalaProviders` and `DesignsystemetProvider` automatically set the `dir` attribute based on the current locale.

### Rules

1. No hardcoded strings in UI components -- use `t()` for everything user-visible.
2. All formatting (dates, numbers, currency) must go through formatters, not raw `toLocaleString()`.
3. Every new i18n key must be added to all three locale files.

---

## 7. Testing

### Test Types

| Type | Location | Runner | Environment |
|------|----------|--------|-------------|
| SDK unit tests | `packages/sdk/src/__tests__/` | Vitest | jsdom |
| Convex function tests | `tests/convex/` | Vitest | node |
| E2E backend tests | `tests/convex/e2e/` | Custom runner | node |
| Browser E2E | `tests/e2e/` | Playwright | Desktop Chrome |

### Running Tests

```bash
# SDK unit tests (54 tests)
pnpm sdk:test

# Convex function tests (472 tests)
pnpm test:convex
pnpm test:convex:watch          # Watch mode

# Single test file
cd tests && npx vitest run convex/path/to/file.test.ts

# E2E backend tests
pnpm test:convex:e2e            # Core suite
pnpm test:convex:e2e:all        # All suites
pnpm test:convex:e2e:journeys   # User journey suite
pnpm test:convex:e2e:performance # Performance suite
pnpm test:convex:e2e:edge-cases # Edge case suite

# Browser E2E
pnpm test:e2e

# Full suite
pnpm test:all
```

### SDK Test Pattern

SDK tests use Vitest + jsdom + React Testing Library. They mock Convex hooks to test hook behavior in isolation:

```typescript
import { describe, it, expect, vi } from 'vitest';
import { renderHook } from '@testing-library/react';
import { useReviews } from '../hooks/use-reviews';

// Mock Convex hooks
vi.mock('convex/react', () => ({
  useQuery: vi.fn(),
  useMutation: vi.fn(() => vi.fn()),
}));

describe('useReviews', () => {
  it('returns empty array when no data', () => {
    const { result } = renderHook(() => useReviews(undefined));
    expect(result.current.reviews).toEqual([]);
    expect(result.current.isLoading).toBe(false);
  });
});
```

### Convex Function Test Pattern

Convex tests use `convex-test` utilities to run functions in an isolated test environment:

```typescript
import { convexTest } from 'convex-test';
import { describe, it, expect } from 'vitest';
import schema from '../../convex/schema';

describe('reviews.list', () => {
  it('returns reviews for tenant', async () => {
    const t = convexTest(schema);
    // ... seed data, run query, assert results
  });
});
```

### Test Configuration

- `tests/vitest.config.ts` -- Convex test config
- `packages/sdk/vitest.config.ts` -- SDK test config
- `playwright.config.ts` -- Browser E2E config (Desktop Chrome, 1 worker, sequential)

---

## 8. Design Systems

### Digdir Apps (`web`, `backoffice`, `minside`)

Use `@xala/ds`, which is built on `@digdir/designsystemet-react`:

```typescript
import {
  AppHeader,
  HeaderLogo,
  DesignsystemetProvider,
  DialogProvider,
  ErrorBoundary,
} from '@xala/ds';
```

Theme setup:
```typescript
import '@xala/ds/styles';                            // Base CSS
import '@xala/ds-themes/themes/digilist.css';        // Theme tokens
import '@xala/ds-themes/themes/xala-navy-extensions.css'; // Extensions
import '@xala/ds-themes/themes/shared-mobile.css';   // Mobile responsive
import '@xala/ds/global';                            // Global font settings
```

Provider:
```typescript
<DesignsystemetProvider theme="digilist" colorScheme={colorScheme} size="md">
  {children}
</DesignsystemetProvider>
```

### Platform Apps (`saas-admin`, `dashboard`)

Use `@xala-technologies/platform-ui`:

```typescript
import {
  AppLayout,
  DashboardSidebar,
  DashboardHeader,
  SkipLinks,
  Stack,
  Heading,
  Text,
  Card,
  useTheme,
} from '@xala-technologies/platform-ui';
```

Style setup:
```typescript
import '@xala-technologies/platform-ui/styles';
```

Provider (via `@xalabaas/app-shell`):
```typescript
<XalaProviders appId="saas-admin" defaultLocale="nb">
  {children}
</XalaProviders>
```

### When to Use Which

- Building a citizen-facing or tenant-operator UI: Use `@xala/ds` (Designsystemet).
- Building a platform-level admin UI: Use `@xala-technologies/platform-ui`.
- Both systems support light/dark mode, responsive layouts, and accessibility.

---

## 9. Security

### Tenant Isolation

Tenant isolation is the most critical security invariant. Every data access is scoped to a tenant.

**Non-negotiable rules:**

1. **Every query and mutation must validate tenant membership.** Functions must verify the requesting user belongs to the tenant being accessed.
2. **Component functions receive `tenantId` as `v.string()`.** This is validated at the facade layer before being passed down.
3. **Indexes always include `tenantId` as the first field.** The `by_tenant` index pattern ensures efficient scoped queries.
4. **No cross-tenant data leaks.** A user in Tenant A must never see data from Tenant B.

### Authentication Requirements

1. All mutations require an authenticated session (except public endpoints like listing search).
2. Session tokens are validated against Convex on every page load via `useAuth`.
3. OAuth and magic link flows are handled server-side through Convex actions.
4. Sessions are per-app (`xalabaas_{appId}_session_token`) with cross-app fallback.

### Authorization

1. **Role-based access control (RBAC)** is enforced at the route level in apps (`ProtectedRoute`, `RequirePermission`) and at the function level in Convex.
2. **Module gating** uses `hasModuleEnabled()` to check if a feature is active for the tenant.
3. **Route guards** from `@xalabaas/app-shell`:
   - `RequireAuth` -- User must be authenticated
   - `RequirePermission` -- User must have a specific permission
   - `RequireModule` -- Module must be enabled for tenant
   - `RequireAll` -- All specified permissions AND modules must be satisfied

### Audit Requirements

1. **All mutations must create audit entries** via the audit component (`components.audit.functions.create`).
2. Audit entries record: `tenantId`, `action`, `userId`, `resourceId`, `details`, `timestamp`.
3. The audit log is immutable -- entries cannot be modified or deleted.
4. Audit events are queryable by tenant, user, resource, and action type.

### Component Isolation

1. Components cannot query other components' tables directly.
2. Cross-component communication happens exclusively through the **event bus** (outbox pattern).
3. Event topics follow the format `{component}.{entity}.{action}` (e.g., `bookings.booking.created`).
4. Component functions use `v.string()` for any reference to data outside their own tables.
5. Core tables (`tenants`, `users`, `organizations`, etc.) are the only tables that can be referenced with `v.id()`.

### Rate Limiting

Rate limits are defined in `features/_shared/lib/rateLimits.ts` and enforced in facade mutations:

```typescript
await withRateLimit(ctx, "createBooking", rateLimitKeys.tenant(tenantId));
```

Limits are per-tenant and per-user to prevent abuse while allowing legitimate high-volume tenants.

### Idempotency

Mutations support idempotency keys to prevent duplicate operations (e.g., double-booking from network retries). The key is typically derived from the input parameters and checked before executing the mutation.
